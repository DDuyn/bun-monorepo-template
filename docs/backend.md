# Backend Architecture

## Pattern: Vertical Slices with Use-Cases

The backend is organized by **feature modules**, not by technical layers. Each feature lives in its own folder with subdirectories for domain, infrastructure, use-cases, and tests.

```
apps/backend/src/
├── config/
│   └── env.ts                    # Zod-validated environment variables
├── infrastructure/
│   └── db/
│       ├── client.ts             # Drizzle + bun:sqlite connection
│       ├── schema.ts             # Barrel re-export of all tables
│       └── migrations/           # Generated by drizzle-kit
├── middleware/
│   ├── error-handler.ts          # Global error catch + ErrorCode→HTTP mapping
│   └── jwt.ts                    # JWT verification guard
├── modules/
│   ├── auth/
│   │   ├── domain/
│   │   │   └── user.ts           # User entity (rich domain model)
│   │   ├── infrastructure/
│   │   │   ├── auth.table.ts     # Drizzle table definition
│   │   │   └── auth.repository.ts # Data access interface + implementation
│   │   ├── use-cases/
│   │   │   ├── register.ts       # Registration use-case
│   │   │   └── login.ts          # Login use-case
│   │   ├── tests/
│   │   │   ├── user.test.ts      # Entity tests
│   │   │   ├── register.test.ts  # Use-case tests
│   │   │   └── login.test.ts
│   │   └── auth.api.ts           # Hono sub-app (composition root)
│   ├── items/
│   │   ├── domain/
│   │   │   └── item.ts
│   │   ├── infrastructure/
│   │   │   ├── items.table.ts
│   │   │   └── items.repository.ts
│   │   ├── use-cases/
│   │   │   ├── create-item.ts
│   │   │   ├── get-item.ts
│   │   │   ├── list-items.ts
│   │   │   ├── update-item.ts
│   │   │   ├── activate-item.ts
│   │   │   ├── deactivate-item.ts
│   │   │   └── delete-item.ts
│   │   ├── tests/
│   │   │   ├── item.test.ts
│   │   │   ├── create-item.test.ts
│   │   │   ├── get-item.test.ts
│   │   │   ├── list-items.test.ts
│   │   │   ├── update-item.test.ts
│   │   │   ├── activate-item.test.ts
│   │   │   ├── deactivate-item.test.ts
│   │   │   └── delete-item.test.ts
│   │   └── items.api.ts
│   └── health/
│       └── health.api.ts         # Simple health check (no layers needed)
├── app.ts                        # Hono app factory, middleware, route mounting
└── index.ts                      # Entry point (starts Bun server)
```

## Module structure

Every feature module follows the same subdirectory pattern:

```
modules/[feature]/
├── domain/                       # Entity classes with behavior
├── infrastructure/               # Table definitions + repository
├── use-cases/                    # One file per operation
├── tests/                        # One test file per entity/use-case
└── [feature].api.ts              # Hono sub-app (composition root)
```

| Directory/File | Responsibility | Returns |
|------|---------------|---------|
| `domain/[entity].ts` | Entity class with behavior and invariants | `Result<Entity, AppError>` from factory methods |
| `infrastructure/[feature].table.ts` | Drizzle table definition (schema) | `sqliteTable(...)` |
| `infrastructure/[feature].repository.ts` | Interface + factory function for data access | Promises of domain entities |
| `use-cases/[operation].ts` | Factory function for a single business operation | `Promise<Result<T, AppError>>` |
| `[feature].api.ts` | Hono sub-app with route handlers, wires use-cases | Hono responses |
| `tests/[entity].test.ts` | Tests for the domain entity | — |
| `tests/[operation].test.ts` | Tests for a specific use-case | — |

Not every module needs all layers. The `health` module only has `health.api.ts` because it has no business logic, no data, and no domain.

## Why vertical slices

**Locality.** When you're working on items, you open `modules/items/` and everything is there. You never need to jump between `controllers/`, `services/`, `repositories/` folders to understand a feature.

**Isolation.** Modules don't import from each other (unless there's a genuine domain relationship). This makes it safe to delete, rename, or rewrite a module without cascading changes.

**Scalability.** Adding a new feature means creating a new folder. The existing modules don't change. This is much simpler than modifying a horizontal layer structure where you'd touch multiple directories.

## Rich domain models (DDD Lite)

Entities are classes with behavior, not plain data bags. The `Item` class (`domain/item.ts`) is a good example:

```ts
export class Item {
  // Factory — validates invariants, returns Result
  static create(name: string, description: string, userId: string): Result<Item, AppError> {
    if (name.trim().length === 0) {
      return err(validationError('Item name cannot be empty'));
    }
    // ...more validation
    return ok(new Item({ /* ... */ }));
  }

  // State transition — enforces business rules
  activate(): Result<Item, AppError> {
    if (this._status === 'active') {
      return err(validationError('Item is already active'));
    }
    this._status = 'active';
    this._updatedAt = new Date();
    return ok(this);
  }

  // Immutable update — returns a new instance
  updateDetails(name?: string, description?: string): Result<Item, AppError> {
    return ok(new Item({ ...this, name: name ?? this.name }));
  }
}
```

**Why rich over anemic:**
- Invariants (e.g., "name can't be empty", "can't activate an already active item") live in the entity, not scattered across use-cases.
- State transitions (`activate`, `deactivate`) are explicit methods with guards, not arbitrary field mutations.
- `create()` is a static factory that validates and returns `Result`, so you can never have an invalid entity.
- `fromPersistence()` bypasses validation for data already in the database.

**When to use classes vs. pure functions:** Use classes when the entity has invariants or state transitions. For simple transformations or value objects with no behavior, a plain function or type is fine.

## Use-case pattern

Each use-case is a single function created by a factory. The factory receives dependencies (typically the repository):

```ts
// use-cases/create-item.ts
export type CreateItem = (
  input: CreateItemInput,
  userId: string,
) => Promise<Result<ItemResponse, AppError>>;

export function createCreateItem(repository: ItemsRepository): CreateItem {
  return async (input, userId) => {
    const result = Item.create(input.name, input.description ?? '', userId);
    if (!result.ok) return result;

    const item = result.value;
    await repository.create(item);
    return ok(item.toResponse());
  };
}
```

**Why use-cases over a service object:**
- Each operation is independently testable and importable.
- Adding a new operation doesn't modify existing files.
- The function signature (type alias) serves as a clear contract.
- No large service interface that grows unboundedly.

## Request flow

An HTTP request flows through these layers:

```
HTTP Request
    │
    ▼
┌─────────────────────────────────────┐
│  Hono Middleware                     │
│  (logger → cors → error-handler)    │
└─────────────┬───────────────────────┘
              │
              ▼
┌─────────────────────────────────────┐
│  [feature].api.ts                    │
│  1. Parse/validate input (Zod)       │
│  2. Extract JWT payload if needed    │
│  3. Call use-case function           │
│  4. Map Result → HTTP response       │
└─────────────┬───────────────────────┘
              │
              ▼
┌─────────────────────────────────────┐
│  use-cases/[operation].ts            │
│  1. Orchestrate business logic       │
│  2. Call repository for data         │
│  3. Use domain entity methods        │
│  4. Return Result<T, AppError>       │
└─────────────┬───────────────────────┘
              │
              ▼
┌─────────────────────────────────────┐
│  infrastructure/[feature].repository │
│  1. Query/insert via Drizzle         │
│  2. Map DB rows → domain entities    │
│  3. Return entities or null          │
└─────────────┬───────────────────────┘
              │
              ▼
┌─────────────────────────────────────┐
│  domain/[entity].ts                  │
│  Entity classes with behavior        │
│  Validates invariants                │
│  Enforces state transitions          │
└─────────────────────────────────────┘
```

### Concrete example: `POST /api/items`

1. **api layer** (`items.api.ts`): Parses body with `createItemInputSchema.safeParse()`. If invalid, returns 400. Extracts `userId` from JWT payload. Calls the `createItem` use-case.
2. **use-case** (`use-cases/create-item.ts`): Calls `Item.create()` to build a valid entity. If validation fails, the Result error propagates. Calls `repository.create()` to persist. Returns `ok(item.toResponse())`.
3. **repository layer** (`infrastructure/items.repository.ts`): Inserts a row into the `items` table via Drizzle.
4. **domain layer** (`domain/item.ts`): `Item.create()` validates name length, description length, sets initial status to `inactive`, generates UUID, returns the entity wrapped in `Result`.

## Hono sub-apps and mounting

Each module exports a Hono sub-app. The main `app.ts` mounts them:

```ts
// app.ts
app.route('/api/health', healthApi);
app.route('/api/auth', authApi);
app.route('/api/items', itemsApi);
```

Protected modules apply the JWT guard at the sub-app level:

```ts
// items.api.ts
const items = new Hono<Env>();
items.use('*', jwtGuard);  // All routes in this sub-app require auth
```

This means the JWT middleware only runs for routes under `/api/items`, while `/api/auth` and `/api/health` remain public.

## Dependency injection

Dependencies are passed as function parameters (manual DI), not via a container:

```ts
// Wiring in the API file (composition root)
const repository = createItemsRepository(db);
const createItem = createCreateItem(repository);
const getItem = createGetItem(repository);
const listItems = createListItems(repository);
// ... each use-case gets the repository injected
```

**Why manual DI over a container:**
- Zero overhead — no reflection, no decorators, no registration
- Easy to understand — follow the function calls
- Easy to test — pass a mock repository directly

The wiring happens at the module boundary (`[feature].api.ts`), which acts as the composition root for that feature.

## Environment configuration

Environment variables are validated at startup with Zod (`config/env.ts`):

```ts
const envSchema = z.object({
  PORT: z.coerce.number().default(3000),
  DATABASE_URL: z.string().default('./local.db'),
  JWT_SECRET: z.string().min(1),
});
```

If validation fails, the process exits immediately with a clear error message. This guarantees that by the time any handler runs, all environment variables are present and correctly typed.
