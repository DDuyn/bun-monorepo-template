# Backend Architecture

## Pattern: Vertical Slices with DDD Lite

The backend is organized by **feature modules**, not by technical layers. Instead of grouping all controllers together, all services together, etc., each feature lives in its own folder with everything it needs.

```
apps/backend/src/
├── config/
│   └── env.ts                    # Zod-validated environment variables
├── infrastructure/
│   └── db/
│       ├── client.ts             # Drizzle + bun:sqlite connection
│       ├── schema.ts             # Barrel re-export of all tables
│       └── migrations/           # Generated by drizzle-kit
├── middleware/
│   ├── error-handler.ts          # Global error catch + ErrorCode→HTTP mapping
│   └── jwt.ts                    # JWT verification guard
├── modules/
│   ├── auth/
│   │   ├── auth.table.ts         # Drizzle table definition
│   │   ├── auth.domain.ts        # User entity (rich domain model)
│   │   ├── auth.repository.ts    # Data access interface + implementation
│   │   ├── auth.service.ts       # Business logic (returns Result<T, E>)
│   │   ├── auth.api.ts           # Hono sub-app (routes)
│   │   └── auth.test.ts          # Unit tests
│   ├── items/
│   │   ├── items.table.ts
│   │   ├── items.domain.ts
│   │   ├── items.repository.ts
│   │   ├── items.service.ts
│   │   ├── items.api.ts
│   │   └── items.test.ts
│   └── health/
│       └── health.api.ts         # Simple health check (no layers needed)
├── app.ts                        # Hono app factory, middleware, route mounting
└── index.ts                      # Entry point (starts Bun server)
```

## File conventions

Every feature module follows the same naming pattern: `[feature].layer.ts`

| File | Responsibility | Returns |
|------|---------------|---------|
| `[feature].table.ts` | Drizzle table definition (schema) | `sqliteTable(...)` |
| `[feature].domain.ts` | Entity class with behavior and invariants | `Result<Entity, AppError>` from factory methods |
| `[feature].repository.ts` | Interface + factory function for data access | Promises of domain entities |
| `[feature].service.ts` | Interface + factory function for business logic | `Promise<Result<T, AppError>>` |
| `[feature].api.ts` | Hono sub-app with route handlers | Hono responses |
| `[feature].test.ts` | Tests for domain + service layers | — |

Not every module needs all layers. The `health` module only has `health.api.ts` because it has no business logic, no data, and no domain.

## Why vertical slices

**Locality.** When you're working on items, you open `modules/items/` and everything is there. You never need to jump between `controllers/`, `services/`, `repositories/` folders to understand a feature.

**Isolation.** Modules don't import from each other (unless there's a genuine domain relationship). This makes it safe to delete, rename, or rewrite a module without cascading changes.

**Scalability.** Adding a new feature means creating a new folder. The existing modules don't change. This is much simpler than modifying a horizontal layer structure where you'd touch multiple directories.

## Rich domain models (DDD Lite)

Entities are classes with behavior, not plain data bags. The `Item` class (`items.domain.ts:26`) is a good example:

```ts
export class Item {
  // Factory — validates invariants, returns Result
  static create(name: string, description: string, userId: string): Result<Item, AppError> {
    if (name.trim().length === 0) {
      return err(validationError('Item name cannot be empty'));
    }
    // ...more validation
    return ok(new Item({ /* ... */ }));
  }

  // State transition — enforces business rules
  activate(): Result<Item, AppError> {
    if (this._status === 'active') {
      return err(validationError('Item is already active'));
    }
    this._status = 'active';
    this._updatedAt = new Date();
    return ok(this);
  }

  // Immutable update — returns a new instance
  updateDetails(name?: string, description?: string): Result<Item, AppError> {
    return ok(new Item({ ...this, name: name ?? this.name }));
  }
}
```

**Why rich over anemic:**
- Invariants (e.g., "name can't be empty", "can't activate an already active item") live in the entity, not scattered across services.
- State transitions (`activate`, `deactivate`) are explicit methods with guards, not arbitrary field mutations.
- `create()` is a static factory that validates and returns `Result`, so you can never have an invalid entity.
- `fromPersistence()` bypasses validation for data already in the database.

**When to use classes vs. pure functions:** Use classes when the entity has invariants or state transitions. For simple transformations or value objects with no behavior, a plain function or type is fine.

## Request flow

An HTTP request flows through these layers:

```
HTTP Request
    │
    ▼
┌─────────────────────────────────────┐
│  Hono Middleware                     │
│  (logger → cors → error-handler)    │
└─────────────┬───────────────────────┘
              │
              ▼
┌─────────────────────────────────────┐
│  [feature].api.ts                    │
│  1. Parse/validate input (Zod)       │
│  2. Extract JWT payload if needed    │
│  3. Call service method              │
│  4. Map Result → HTTP response       │
└─────────────┬───────────────────────┘
              │
              ▼
┌─────────────────────────────────────┐
│  [feature].service.ts                │
│  1. Orchestrate business logic       │
│  2. Call repository for data         │
│  3. Use domain entity methods        │
│  4. Return Result<T, AppError>       │
└─────────────┬───────────────────────┘
              │
              ▼
┌─────────────────────────────────────┐
│  [feature].repository.ts             │
│  1. Query/insert via Drizzle         │
│  2. Map DB rows → domain entities    │
│  3. Return entities or null          │
└─────────────┬───────────────────────┘
              │
              ▼
┌─────────────────────────────────────┐
│  [feature].domain.ts                 │
│  Entity classes with behavior        │
│  Validates invariants                │
│  Enforces state transitions          │
└─────────────────────────────────────┘
```

### Concrete example: `POST /api/items`

1. **api layer** (`items.api.ts:38`): Parses body with `createItemInputSchema.safeParse()`. If invalid, returns 400. Extracts `userId` from JWT payload. Calls `service.create()`.
2. **service layer** (`items.service.ts:30`): Calls `Item.create()` to build a valid entity. If validation fails, the Result error propagates. Calls `repository.create()` to persist. Returns `ok(item.toResponse())`.
3. **repository layer** (`items.repository.ts:30`): Inserts a row into the `items` table via Drizzle.
4. **domain layer** (`items.domain.ts:38`): `Item.create()` validates name length, description length, sets initial status to `inactive`, generates UUID, returns the entity wrapped in `Result`.

## Hono sub-apps and mounting

Each module exports a Hono sub-app. The main `app.ts` mounts them:

```ts
// app.ts
app.route('/api/health', healthApi);
app.route('/api/auth', authApi);
app.route('/api/items', itemsApi);
```

Protected modules apply the JWT guard at the sub-app level:

```ts
// items.api.ts
const items = new Hono<Env>();
items.use('*', jwtGuard);  // All routes in this sub-app require auth
```

This means the JWT middleware only runs for routes under `/api/items`, while `/api/auth` and `/api/health` remain public.

## Dependency injection

Dependencies are passed as function parameters (manual DI), not via a container:

```ts
// Factory function — dependencies are parameters
export function createItemsService(repository: ItemsRepository): ItemsService { ... }

// Wiring in the API file
const repository = createItemsRepository(db);
const service = createItemsService(repository);
```

**Why manual DI over a container:**
- Zero overhead — no reflection, no decorators, no registration
- Easy to understand — follow the function calls
- Easy to test — pass a mock repository directly

The wiring happens at the module boundary (`[feature].api.ts`), which acts as the composition root for that feature.

## Environment configuration

Environment variables are validated at startup with Zod (`config/env.ts:3`):

```ts
const envSchema = z.object({
  PORT: z.coerce.number().default(3000),
  DATABASE_URL: z.string().default('./local.db'),
  JWT_SECRET: z.string().min(1),
});
```

If validation fails, the process exits immediately with a clear error message. This guarantees that by the time any handler runs, all environment variables are present and correctly typed.
